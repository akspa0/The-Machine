from __future__ import annotations

import json
import os
from pathlib import Path
from typing import List, Dict, Any

from pydub import AudioSegment

from extension_base import ExtensionBase
from utils.theme_segmenter import segment_calls
from finalization_stage import wav_to_mp3
from extensions.bleeper_extension import BleeperExtension


class ShowSplitterExtension(ExtensionBase):
    """Split the completed-show into several shorter *sub-shows*.

    • Finds the full-length MP3 in ``finalized/show/``.
    • Reads the master timeline from ``show/show.json``.
    • Uses call LLM *categories* to create balanced groups (default = 4).
    • Slices the audio, exports MP3, rewrites call logs, then optionally runs
      :class:`extensions.bleeper_extension.BleeperExtension` to create a
      *_bleeped.mp3* variant.
    """

    NAME = "show_splitter"

    def __init__(self, run_folder: Path, num_segments: int = 4):
        super().__init__(run_folder)
        self.run_folder = Path(run_folder)
        self.num_segments = num_segments
        self.show_dir = self.run_folder / "finalized" / "show"
        self.subshows_dir = self.show_dir / "subshows"
        self.subshows_dir.mkdir(parents=True, exist_ok=True)

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def _find_completed_show_mp3(self) -> Path | None:
        """Return path to the first non-bleeped MP3 inside finalized/show."""
        # 1) Prefer non-bleep MP3s in finalized/show
        candidates = [p for p in self.show_dir.glob("*.mp3") if "bleep" not in p.name.lower()]

        # 2) Fallback: check run_folder/show (where show_fixup writes show_fixed.mp3)
        if not candidates:
            alt_dir = self.run_folder / "show"
            candidates = [p for p in alt_dir.glob("*.mp3") if "bleep" not in p.name.lower()]

        # 3) Prefer a file named show_fixed.mp3 or completed-show.mp3 if present
        preferred = None
        for name in ("show_fixed.mp3", "completed-show.mp3"):
            preferred = next((p for p in candidates if p.name == name), None)
            if preferred:
                break

        return preferred or (candidates[0] if candidates else None)

    def _load_timeline(self) -> List[Dict[str, Any]]:
        timeline_path = self.run_folder / "show" / "show.json"
        if not timeline_path.exists():
            self.log(f"Timeline JSON not found: {timeline_path}")
            return []
        with open(timeline_path, "r", encoding="utf-8") as f:
            return json.load(f)

    def _collect_calls(self, timeline: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Build a list of call dicts enriched with tag information."""
        calls: List[Dict[str, Any]] = []
        for entry in timeline:
            if "call_id" not in entry:
                continue  # skip tones
            cid = entry["call_id"]
            start = float(entry.get("start", 0))
            end = float(entry.get("end", 0))
            duration = max(0.0, end - start)
            # Read categories file generated by LLM (comma-sep list)
            cat_path = self.run_folder / "llm" / cid / "call_categories.txt"
            tags: List[str] = []
            if cat_path.exists():
                try:
                    text = cat_path.read_text(encoding="utf-8").strip()
                    tags = [t.strip().lower() for t in text.split(",") if t.strip()]
                except Exception:  # pragma: no cover – malformed file
                    pass
            calls.append(
                {
                    "id": cid,
                    "start": start,
                    "end": end,
                    "duration": duration,
                    "tags": tags or ["unknown"],
                    "title": entry.get("call_title", cid),
                }
            )
        return calls

    def _write_log_file(self, sub_calls: List[Dict[str, Any]], out_path: Path):
        """Create human-readable timeline for a sub-show."""
        if not sub_calls:
            return
        base_start = sub_calls[0]["start"]

        def hms(sec: float) -> str:
            sec = max(0, int(sec))
            h = sec // 3600
            m = (sec % 3600) // 60
            s = sec % 60
            return f"{h:02d}:{m:02d}:{s:02d}"

        with open(out_path, "w", encoding="utf-8") as f:
            for c in sub_calls:
                rel_start = c["start"] - base_start
                rel_end = c["end"] - base_start
                cats = ", ".join(c["tags"])
                f.write(
                    f"{hms(rel_start)} – {hms(rel_end)}  {c['title']}  [{cats}]\n"
                )

    # ------------------------------------------------------------------
    # Main logic
    # ------------------------------------------------------------------
    def execute(self):  # noqa: D401 – imperative method
        show_mp3 = self._find_completed_show_mp3()
        if not show_mp3 or not show_mp3.exists():
            self.log("Completed-show MP3 not found – skipping splitter.")
            return

        timeline = self._load_timeline()
        if not timeline:
            self.log("No timeline data – skipping splitter.")
            return

        calls = self._collect_calls(timeline)
        if len(calls) <= 1:
            self.log(f"Not enough calls ({len(calls)}) to split.")
            return

        # ----------------------------------------------------------------
        # Segment into bins
        # ----------------------------------------------------------------
        bins = segment_calls(calls, num_segments=self.num_segments)
        self.log(f"Segmented into {len(bins)} sub-shows.")

        # Load full audio once
        full_audio = AudioSegment.from_mp3(show_mp3)

        enhancements: List[Dict[str, Any]] = []

        for idx, bin_calls in enumerate(bins):
            sub_start = bin_calls[0]["start"]
            sub_end = bin_calls[-1]["end"]
            slice_audio = full_audio[int(sub_start * 1000) : int(sub_end * 1000)]

            part_dir = self.subshows_dir
            part_dir.mkdir(parents=True, exist_ok=True)

            wav_path = part_dir / f"subshow{idx}.wav"
            mp3_path = part_dir / f"subshow{idx}.mp3"
            bleeped_mp3 = part_dir / f"subshow{idx}_bleeped.mp3"
            log_path = part_dir / f"subshow{idx}_log.txt"

            # Export WAV and convert to MP3
            slice_audio.export(wav_path, format="wav")
            wav_to_mp3(wav_path, mp3_path)

            # Write log file
            self._write_log_file(bin_calls, log_path)

            # ---- Bleeper pass ----
            try:
                # Bleeper needs a file named show.wav inside output_root.
                show_wav_alias = part_dir / "show.wav"
                if not show_wav_alias.exists():
                    os.link(wav_path, show_wav_alias)  # hard-link to save space
                BleeperExtension(output_root=part_dir).run()
                bleeped_wav = part_dir / "show_bleeped.wav"
                if bleeped_wav.exists():
                    wav_to_mp3(bleeped_wav, bleeped_mp3)
            except Exception as exc:  # pragma: no cover – bleeper failure is non-fatal
                self.log(f"Bleeper failed for part {idx}: {exc}")

            enhancements.append(
                {
                    "type": self.NAME,
                    "subshow_index": idx,
                    "output_mp3": str(mp3_path.relative_to(self.run_folder)),
                    "bleeped_mp3": str(bleeped_mp3.relative_to(self.run_folder)) if bleeped_mp3.exists() else None,
                    "calls": [
                        {
                            "call_id": c["id"],
                            "start_rel": c["start"] - sub_start,
                            "end_rel": c["end"] - sub_start,
                            "tags": c["tags"],
                        }
                        for c in bin_calls
                    ],
                }
            )

        # ----------------------------------------------------------------
        # Persist enhancement manifest
        # ----------------------------------------------------------------
        manifest_path = self.show_dir / "manifest.json"
        if manifest_path.exists():
            try:
                with open(manifest_path, "r", encoding="utf-8") as f:
                    manifest = json.load(f)
            except Exception:
                manifest = {}
        else:
            manifest = {}
        if "enhancements" not in manifest:
            manifest["enhancements"] = []
        manifest["enhancements"].extend(enhancements)
        with open(manifest_path, "w", encoding="utf-8") as f:
            json.dump(manifest, f, indent=2)
        self.log("Show Splitter completed – %s sub-shows created.", len(enhancements))


# ----------------------------------------------------------------------
# Hook for extension_runner
# ----------------------------------------------------------------------

def run(run_folder: Path):  # noqa: D401 – external entry-point
    ShowSplitterExtension(run_folder).execute()


# ----------------------------------------------------------------------
#  Command-line usage: ``python -m extensions.show_splitter_extension …``
# ----------------------------------------------------------------------

if __name__ == '__main__':
    import argparse
    ap = argparse.ArgumentParser(description='Split a completed-show into themed sub-shows.')
    ap.add_argument('run_folder', type=str, help='Path to outputs/run-YYYY… folder')
    ap.add_argument('--segments', type=int, default=4, metavar='N', help='Number of sub-shows to create (default: 4)')
    args = ap.parse_args()

    ShowSplitterExtension(Path(args.run_folder), num_segments=args.segments).execute() 